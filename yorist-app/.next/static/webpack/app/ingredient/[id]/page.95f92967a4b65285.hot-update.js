"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/ingredient/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/ingredientSync.ts":
/*!***********************************!*\
  !*** ./src/lib/ingredientSync.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createIngredient: function() { return /* binding */ createIngredient; },\n/* harmony export */   deleteIngredientIfUnused: function() { return /* binding */ deleteIngredientIfUnused; },\n/* harmony export */   findIngredientByName: function() { return /* binding */ findIngredientByName; },\n/* harmony export */   getIngredientById: function() { return /* binding */ getIngredientById; },\n/* harmony export */   getPopularIngredients: function() { return /* binding */ getPopularIngredients; },\n/* harmony export */   mergeIngredients: function() { return /* binding */ mergeIngredients; },\n/* harmony export */   searchIngredients: function() { return /* binding */ searchIngredients; },\n/* harmony export */   sortIngredients: function() { return /* binding */ sortIngredients; },\n/* harmony export */   toggleIngredientFavorite: function() { return /* binding */ toggleIngredientFavorite; },\n/* harmony export */   triggerIngredientSync: function() { return /* binding */ triggerIngredientSync; },\n/* harmony export */   updateIngredient: function() { return /* binding */ updateIngredient; },\n/* harmony export */   useIngredientSync: function() { return /* binding */ useIngredientSync; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://rshosgiwnqcvwfnkqdwc.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJzaG9zZ2l3bnFjdndmbmtxZHdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE2MzMxNjEsImV4cCI6MjA2NzIwOTE2MX0.9yrX80F0-3w0H8u3Qx449oYRpD4vA1wEjEYP7mdylGg\");\nlet version = 0;\nconst listeners = [];\nfunction useIngredientSync() {\n    const [, setTick] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    function onSync() {\n        setTick((t)=>t + 1);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        listeners.push(onSync);\n        return ()=>{\n            const idx = listeners.indexOf(onSync);\n            if (idx > -1) listeners.splice(idx, 1);\n        };\n    }, []);\n    return version;\n}\nfunction triggerIngredientSync() {\n    version++;\n    listeners.forEach((fn)=>fn());\n}\n// 재료 검색 함수\nasync function searchIngredients(query) {\n    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").ilike(\"name\", \"%\".concat(query, \"%\")).order(\"is_favorite\", {\n            ascending: false\n        }) // 즐겨찾기 재료를 먼저 표시\n        .order(\"name\", {\n            ascending: true\n        }).limit(limit);\n        if (error) {\n            console.error(\"재료 검색 실패:\", error);\n            return [];\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"재료 검색 중 오류:\", error);\n        return [];\n    }\n}\n// 재료 상세 정보 조회 함수\nasync function getIngredientById(id) {\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").eq(\"id\", id).single();\n        if (error) {\n            console.error(\"재료 조회 실패:\", error);\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error(\"재료 조회 중 오류:\", error);\n        return null;\n    }\n}\n// 재료 업데이트 함수\nasync function updateIngredient(id, updates) {\n    try {\n        const { error } = await supabase.from(\"ingredients_master\").update(updates).eq(\"id\", id);\n        if (error) {\n            console.error(\"재료 업데이트 실패:\", error);\n            return false;\n        }\n        triggerIngredientSync();\n        return true;\n    } catch (error) {\n        console.error(\"재료 업데이트 중 오류:\", error);\n        return false;\n    }\n}\n// 재료 삭제 함수 (다른 레시피에서 사용되지 않는 경우에만)\nasync function deleteIngredientIfUnused(id) {\n    try {\n        // 해당 재료를 사용하는 다른 레시피가 있는지 확인\n        const { data: recipes, error: recipesError } = await supabase.from(\"recipes\").select(\"ingredients\").contains(\"ingredients\", [\n            {\n                ingredient_id: id\n            }\n        ]);\n        if (recipesError) {\n            console.error(\"레시피 조회 실패:\", recipesError);\n            return false;\n        }\n        // 다른 레시피에서 사용되지 않는 경우에만 삭제\n        if (!recipes || recipes.length === 0) {\n            const { error } = await supabase.from(\"ingredients_master\").delete().eq(\"id\", id);\n            if (error) {\n                console.error(\"재료 삭제 실패:\", error);\n                return false;\n            }\n            triggerIngredientSync();\n            return true;\n        }\n        return false; // 다른 레시피에서 사용 중\n    } catch (error) {\n        console.error(\"재료 삭제 중 오류:\", error);\n        return false;\n    }\n}\n// 재료 즐겨찾기 토글 함수\nasync function toggleIngredientFavorite(id) {\n    try {\n        // 현재 즐겨찾기 상태 조회\n        const current = await getIngredientById(id);\n        if (!current) return false;\n        const newFavoriteState = !current.is_favorite;\n        const { error } = await supabase.from(\"ingredients_master\").update({\n            is_favorite: newFavoriteState\n        }).eq(\"id\", id);\n        if (error) {\n            console.error(\"재료 즐겨찾기 토글 실패:\", error);\n            return false;\n        }\n        triggerIngredientSync();\n        return true;\n    } catch (error) {\n        console.error(\"재료 즐겨찾기 토글 중 오류:\", error);\n        return false;\n    }\n}\n// 재료명으로 재료 찾기 (정확한 매칭)\nasync function findIngredientByName(name) {\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").ilike(\"name\", name.trim()).single();\n        if (error) {\n            // 재료가 없는 경우 null 반환 (에러가 아님)\n            if (error.code === \"PGRST116\") {\n                return null;\n            }\n            console.error(\"재료 검색 실패:\", error);\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error(\"재료 검색 중 오류:\", error);\n        return null;\n    }\n}\n// 새 재료 생성 함수\nasync function createIngredient(ingredient) {\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").insert({\n            name: ingredient.name.trim(),\n            unit: ingredient.unit || \"개\",\n            shop_url: ingredient.shop_url || null,\n            is_favorite: ingredient.is_favorite || false\n        }).select(\"id\").single();\n        if (error) {\n            console.error(\"재료 생성 실패:\", error);\n            return null;\n        }\n        triggerIngredientSync();\n        return data.id;\n    } catch (error) {\n        console.error(\"재료 생성 중 오류:\", error);\n        return null;\n    }\n}\n// 자주 사용되는 재료 추천 함수\nasync function getPopularIngredients() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n    try {\n        // 즐겨찾기된 재료들을 우선적으로 가져오기\n        const { data: favoriteIngredients, error: favoriteError } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").eq(\"is_favorite\", true).order(\"name\", {\n            ascending: true\n        }).limit(Math.ceil(limit / 2));\n        if (favoriteError) {\n            console.error(\"즐겨찾기 재료 조회 실패:\", favoriteError);\n        }\n        // 나머지는 최근 생성된 재료들로 채우기\n        const remainingLimit = limit - ((favoriteIngredients === null || favoriteIngredients === void 0 ? void 0 : favoriteIngredients.length) || 0);\n        let recentIngredients = [];\n        if (remainingLimit > 0) {\n            const { data: recent, error: recentError } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").order(\"created_at\", {\n                ascending: false\n            }).limit(remainingLimit);\n            if (recentError) {\n                console.error(\"최근 재료 조회 실패:\", recentError);\n            } else {\n                recentIngredients = recent || [];\n            }\n        }\n        // 즐겨찾기 재료와 최근 재료를 합치고 중복 제거\n        const allIngredients = [\n            ...favoriteIngredients || [],\n            ...recentIngredients\n        ];\n        const uniqueIngredients = allIngredients.reduce((acc, current)=>{\n            const exists = acc.find((item)=>item.id === current.id);\n            if (!exists) {\n                acc.push(current);\n            }\n            return acc;\n        }, []);\n        return uniqueIngredients.slice(0, limit);\n    } catch (error) {\n        console.error(\"인기 재료 조회 중 오류:\", error);\n        return [];\n    }\n}\n// 재료 검색 결과 정렬 함수\nfunction sortIngredients(ingredients) {\n    let sortBy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"favorite\";\n    const sorted = [\n        ...ingredients\n    ];\n    switch(sortBy){\n        case \"name\":\n            return sorted.sort((a, b)=>a.name.localeCompare(b.name));\n        case \"favorite\":\n            return sorted.sort((a, b)=>{\n                if (a.is_favorite && !b.is_favorite) return -1;\n                if (!a.is_favorite && b.is_favorite) return 1;\n                return a.name.localeCompare(b.name);\n            });\n        case \"recent\":\n            return sorted.sort((a, b)=>{\n                const dateA = new Date(a.created_at || 0);\n                const dateB = new Date(b.created_at || 0);\n                return dateB.getTime() - dateA.getTime();\n            });\n        default:\n            return sorted;\n    }\n}\n// 두 재료를 통합(merge)하는 함수: oldId의 모든 레시피를 newId로 교체, oldId가 더 이상 사용되지 않으면 삭제\nasync function mergeIngredients(oldId, newId) {\n    try {\n        // 1. 모든 레시피를 불러와서 oldId가 포함된 레시피만 필터링\n        const { data: allRecipes, error: recipeError } = await supabase.from(\"recipes\").select(\"id, ingredients\");\n        if (recipeError) {\n            console.error(\"레시피 조회 실패:\", recipeError);\n            return false;\n        }\n        const recipes = (allRecipes || []).filter((recipe)=>Array.isArray(recipe.ingredients) && recipe.ingredients.some((ing)=>ing.ingredient_id === oldId));\n        for (const recipe of recipes){\n            const updatedIngredients = (recipe.ingredients || []).map((ing)=>ing.ingredient_id === oldId ? {\n                    ...ing,\n                    ingredient_id: newId\n                } : ing);\n            await supabase.from(\"recipes\").update({\n                ingredients: updatedIngredients\n            }).eq(\"id\", recipe.id);\n        }\n        // 2. oldId가 더 이상 사용되지 않으면 ingredients_master에서 삭제\n        const stillUsed = (allRecipes || []).filter((recipe)=>Array.isArray(recipe.ingredients) && recipe.ingredients.some((ing)=>ing.ingredient_id === oldId));\n        if (!stillUsed || stillUsed.length === 0) {\n            await supabase.from(\"ingredients_master\").delete().eq(\"id\", oldId);\n        }\n        triggerIngredientSync();\n        return true;\n    } catch (error) {\n        console.error(\"재료 통합(merge) 중 오류:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaW5ncmVkaWVudFN5bmMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ1M7QUFHckQsTUFBTUcsV0FBV0QsbUVBQVlBLENBQzNCRSwwQ0FBb0MsRUFDcENBLGtOQUF5QztBQUczQyxJQUFJSSxVQUFVO0FBQ2QsTUFBTUMsWUFBNEIsRUFBRTtBQUU3QixTQUFTQztJQUNkLE1BQU0sR0FBR0MsUUFBUSxHQUFHViwrQ0FBUUEsQ0FBQztJQUM3QixTQUFTVztRQUFXRCxRQUFRRSxDQUFBQSxJQUFLQSxJQUFJO0lBQUk7SUFDekNiLGdEQUFTQSxDQUFDO1FBQ1JTLFVBQVVLLElBQUksQ0FBQ0Y7UUFDZixPQUFPO1lBQ0wsTUFBTUcsTUFBTU4sVUFBVU8sT0FBTyxDQUFDSjtZQUM5QixJQUFJRyxNQUFNLENBQUMsR0FBR04sVUFBVVEsTUFBTSxDQUFDRixLQUFLO1FBQ3RDO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBT1A7QUFDVDtBQUVPLFNBQVNVO0lBQ2RWO0lBQ0FDLFVBQVVVLE9BQU8sQ0FBQ0MsQ0FBQUEsS0FBTUE7QUFDMUI7QUFFQSxXQUFXO0FBQ0osZUFBZUMsa0JBQWtCQyxLQUFhO1FBQUVDLFFBQUFBLGlFQUFnQjtJQUNyRSxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU10QixTQUMzQnVCLElBQUksQ0FBQyxzQkFDTEMsTUFBTSxDQUFDLHFEQUNQQyxLQUFLLENBQUMsUUFBUSxJQUFVLE9BQU5OLE9BQU0sTUFDeEJPLEtBQUssQ0FBQyxlQUFlO1lBQUVDLFdBQVc7UUFBTSxHQUFHLGlCQUFpQjtTQUM1REQsS0FBSyxDQUFDLFFBQVE7WUFBRUMsV0FBVztRQUFLLEdBQ2hDUCxLQUFLLENBQUNBO1FBRVQsSUFBSUUsT0FBTztZQUNUTSxRQUFRTixLQUFLLENBQUMsYUFBYUE7WUFDM0IsT0FBTyxFQUFFO1FBQ1g7UUFFQSxPQUFPRCxRQUFRLEVBQUU7SUFDbkIsRUFBRSxPQUFPQyxPQUFPO1FBQ2RNLFFBQVFOLEtBQUssQ0FBQyxlQUFlQTtRQUM3QixPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsaUJBQWlCO0FBQ1YsZUFBZU8sa0JBQWtCQyxFQUFVO0lBQ2hELElBQUk7UUFDRixNQUFNLEVBQUVULElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTXRCLFNBQzNCdUIsSUFBSSxDQUFDLHNCQUNMQyxNQUFNLENBQUMscURBQ1BPLEVBQUUsQ0FBQyxNQUFNRCxJQUNURSxNQUFNO1FBRVQsSUFBSVYsT0FBTztZQUNUTSxRQUFRTixLQUFLLENBQUMsYUFBYUE7WUFDM0IsT0FBTztRQUNUO1FBRUEsT0FBT0Q7SUFDVCxFQUFFLE9BQU9DLE9BQU87UUFDZE0sUUFBUU4sS0FBSyxDQUFDLGVBQWVBO1FBQzdCLE9BQU87SUFDVDtBQUNGO0FBRUEsYUFBYTtBQUNOLGVBQWVXLGlCQUFpQkgsRUFBVSxFQUFFSSxPQUFrQztJQUNuRixJQUFJO1FBQ0YsTUFBTSxFQUFFWixLQUFLLEVBQUUsR0FBRyxNQUFNdEIsU0FDckJ1QixJQUFJLENBQUMsc0JBQ0xZLE1BQU0sQ0FBQ0QsU0FDUEgsRUFBRSxDQUFDLE1BQU1EO1FBRVosSUFBSVIsT0FBTztZQUNUTSxRQUFRTixLQUFLLENBQUMsZUFBZUE7WUFDN0IsT0FBTztRQUNUO1FBRUFQO1FBQ0EsT0FBTztJQUNULEVBQUUsT0FBT08sT0FBTztRQUNkTSxRQUFRTixLQUFLLENBQUMsaUJBQWlCQTtRQUMvQixPQUFPO0lBQ1Q7QUFDRjtBQUVBLG1DQUFtQztBQUM1QixlQUFlYyx5QkFBeUJOLEVBQVU7SUFDdkQsSUFBSTtRQUNGLDZCQUE2QjtRQUM3QixNQUFNLEVBQUVULE1BQU1nQixPQUFPLEVBQUVmLE9BQU9nQixZQUFZLEVBQUUsR0FBRyxNQUFNdEMsU0FDbER1QixJQUFJLENBQUMsV0FDTEMsTUFBTSxDQUFDLGVBQ1BlLFFBQVEsQ0FBQyxlQUFlO1lBQUM7Z0JBQUVDLGVBQWVWO1lBQUc7U0FBRTtRQUVsRCxJQUFJUSxjQUFjO1lBQ2hCVixRQUFRTixLQUFLLENBQUMsY0FBY2dCO1lBQzVCLE9BQU87UUFDVDtRQUVBLDJCQUEyQjtRQUMzQixJQUFJLENBQUNELFdBQVdBLFFBQVFJLE1BQU0sS0FBSyxHQUFHO1lBQ3BDLE1BQU0sRUFBRW5CLEtBQUssRUFBRSxHQUFHLE1BQU10QixTQUNyQnVCLElBQUksQ0FBQyxzQkFDTG1CLE1BQU0sR0FDTlgsRUFBRSxDQUFDLE1BQU1EO1lBRVosSUFBSVIsT0FBTztnQkFDVE0sUUFBUU4sS0FBSyxDQUFDLGFBQWFBO2dCQUMzQixPQUFPO1lBQ1Q7WUFFQVA7WUFDQSxPQUFPO1FBQ1Q7UUFFQSxPQUFPLE9BQU8sZ0JBQWdCO0lBQ2hDLEVBQUUsT0FBT08sT0FBTztRQUNkTSxRQUFRTixLQUFLLENBQUMsZUFBZUE7UUFDN0IsT0FBTztJQUNUO0FBQ0Y7QUFFQSxnQkFBZ0I7QUFDVCxlQUFlcUIseUJBQXlCYixFQUFVO0lBQ3ZELElBQUk7UUFDRixnQkFBZ0I7UUFDaEIsTUFBTWMsVUFBVSxNQUFNZixrQkFBa0JDO1FBQ3hDLElBQUksQ0FBQ2MsU0FBUyxPQUFPO1FBRXJCLE1BQU1DLG1CQUFtQixDQUFDRCxRQUFRRSxXQUFXO1FBRTdDLE1BQU0sRUFBRXhCLEtBQUssRUFBRSxHQUFHLE1BQU10QixTQUNyQnVCLElBQUksQ0FBQyxzQkFDTFksTUFBTSxDQUFDO1lBQUVXLGFBQWFEO1FBQWlCLEdBQ3ZDZCxFQUFFLENBQUMsTUFBTUQ7UUFFWixJQUFJUixPQUFPO1lBQ1RNLFFBQVFOLEtBQUssQ0FBQyxrQkFBa0JBO1lBQ2hDLE9BQU87UUFDVDtRQUVBUDtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9PLE9BQU87UUFDZE0sUUFBUU4sS0FBSyxDQUFDLG9CQUFvQkE7UUFDbEMsT0FBTztJQUNUO0FBQ0Y7QUFFQSx1QkFBdUI7QUFDaEIsZUFBZXlCLHFCQUFxQkMsSUFBWTtJQUNyRCxJQUFJO1FBQ0YsTUFBTSxFQUFFM0IsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNdEIsU0FDM0J1QixJQUFJLENBQUMsc0JBQ0xDLE1BQU0sQ0FBQyxxREFDUEMsS0FBSyxDQUFDLFFBQVF1QixLQUFLQyxJQUFJLElBQ3ZCakIsTUFBTTtRQUVULElBQUlWLE9BQU87WUFDVCw2QkFBNkI7WUFDN0IsSUFBSUEsTUFBTTRCLElBQUksS0FBSyxZQUFZO2dCQUM3QixPQUFPO1lBQ1Q7WUFDQXRCLFFBQVFOLEtBQUssQ0FBQyxhQUFhQTtZQUMzQixPQUFPO1FBQ1Q7UUFFQSxPQUFPRDtJQUNULEVBQUUsT0FBT0MsT0FBTztRQUNkTSxRQUFRTixLQUFLLENBQUMsZUFBZUE7UUFDN0IsT0FBTztJQUNUO0FBQ0Y7QUFFQSxhQUFhO0FBQ04sZUFBZTZCLGlCQUFpQkMsVUFBdUQ7SUFDNUYsSUFBSTtRQUNGLE1BQU0sRUFBRS9CLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTXRCLFNBQzNCdUIsSUFBSSxDQUFDLHNCQUNMOEIsTUFBTSxDQUFDO1lBQ05MLE1BQU1JLFdBQVdKLElBQUksQ0FBQ0MsSUFBSTtZQUMxQkssTUFBTUYsV0FBV0UsSUFBSSxJQUFJO1lBQ3pCQyxVQUFVSCxXQUFXRyxRQUFRLElBQUk7WUFDakNULGFBQWFNLFdBQVdOLFdBQVcsSUFBSTtRQUN6QyxHQUNDdEIsTUFBTSxDQUFDLE1BQ1BRLE1BQU07UUFFVCxJQUFJVixPQUFPO1lBQ1RNLFFBQVFOLEtBQUssQ0FBQyxhQUFhQTtZQUMzQixPQUFPO1FBQ1Q7UUFFQVA7UUFDQSxPQUFPTSxLQUFLUyxFQUFFO0lBQ2hCLEVBQUUsT0FBT1IsT0FBTztRQUNkTSxRQUFRTixLQUFLLENBQUMsZUFBZUE7UUFDN0IsT0FBTztJQUNUO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDWixlQUFla0M7UUFBc0JwQyxRQUFBQSxpRUFBZ0I7SUFDMUQsSUFBSTtRQUNGLHdCQUF3QjtRQUN4QixNQUFNLEVBQUVDLE1BQU1vQyxtQkFBbUIsRUFBRW5DLE9BQU9vQyxhQUFhLEVBQUUsR0FBRyxNQUFNMUQsU0FDL0R1QixJQUFJLENBQUMsc0JBQ0xDLE1BQU0sQ0FBQyxxREFDUE8sRUFBRSxDQUFDLGVBQWUsTUFDbEJMLEtBQUssQ0FBQyxRQUFRO1lBQUVDLFdBQVc7UUFBSyxHQUNoQ1AsS0FBSyxDQUFDdUMsS0FBS0MsSUFBSSxDQUFDeEMsUUFBUTtRQUUzQixJQUFJc0MsZUFBZTtZQUNqQjlCLFFBQVFOLEtBQUssQ0FBQyxrQkFBa0JvQztRQUNsQztRQUVBLHVCQUF1QjtRQUN2QixNQUFNRyxpQkFBaUJ6QyxRQUFTcUMsQ0FBQUEsQ0FBQUEsZ0NBQUFBLDBDQUFBQSxvQkFBcUJoQixNQUFNLEtBQUk7UUFDL0QsSUFBSXFCLG9CQUF3QyxFQUFFO1FBRTlDLElBQUlELGlCQUFpQixHQUFHO1lBQ3RCLE1BQU0sRUFBRXhDLE1BQU0wQyxNQUFNLEVBQUV6QyxPQUFPMEMsV0FBVyxFQUFFLEdBQUcsTUFBTWhFLFNBQ2hEdUIsSUFBSSxDQUFDLHNCQUNMQyxNQUFNLENBQUMscURBQ1BFLEtBQUssQ0FBQyxjQUFjO2dCQUFFQyxXQUFXO1lBQU0sR0FDdkNQLEtBQUssQ0FBQ3lDO1lBRVQsSUFBSUcsYUFBYTtnQkFDZnBDLFFBQVFOLEtBQUssQ0FBQyxnQkFBZ0IwQztZQUNoQyxPQUFPO2dCQUNMRixvQkFBb0JDLFVBQVUsRUFBRTtZQUNsQztRQUNGO1FBRUEsNEJBQTRCO1FBQzVCLE1BQU1FLGlCQUFpQjtlQUFLUix1QkFBdUIsRUFBRTtlQUFNSztTQUFrQjtRQUM3RSxNQUFNSSxvQkFBb0JELGVBQWVFLE1BQU0sQ0FBQyxDQUFDQyxLQUF5QnhCO1lBQ3hFLE1BQU15QixTQUFTRCxJQUFJRSxJQUFJLENBQUNDLENBQUFBLE9BQVFBLEtBQUt6QyxFQUFFLEtBQUtjLFFBQVFkLEVBQUU7WUFDdEQsSUFBSSxDQUFDdUMsUUFBUTtnQkFDWEQsSUFBSXpELElBQUksQ0FBQ2lDO1lBQ1g7WUFDQSxPQUFPd0I7UUFDVCxHQUFHLEVBQUU7UUFFTCxPQUFPRixrQkFBa0JNLEtBQUssQ0FBQyxHQUFHcEQ7SUFDcEMsRUFBRSxPQUFPRSxPQUFPO1FBQ2RNLFFBQVFOLEtBQUssQ0FBQyxrQkFBa0JBO1FBQ2hDLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQSxpQkFBaUI7QUFDVixTQUFTbUQsZ0JBQWdCQyxXQUErQjtRQUFFQyxTQUFBQSxpRUFBeUM7SUFDeEcsTUFBTUMsU0FBUztXQUFJRjtLQUFZO0lBRS9CLE9BQVFDO1FBQ04sS0FBSztZQUNILE9BQU9DLE9BQU9DLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFOUIsSUFBSSxDQUFDZ0MsYUFBYSxDQUFDRCxFQUFFL0IsSUFBSTtRQUMxRCxLQUFLO1lBQ0gsT0FBTzRCLE9BQU9DLElBQUksQ0FBQyxDQUFDQyxHQUFHQztnQkFDckIsSUFBSUQsRUFBRWhDLFdBQVcsSUFBSSxDQUFDaUMsRUFBRWpDLFdBQVcsRUFBRSxPQUFPLENBQUM7Z0JBQzdDLElBQUksQ0FBQ2dDLEVBQUVoQyxXQUFXLElBQUlpQyxFQUFFakMsV0FBVyxFQUFFLE9BQU87Z0JBQzVDLE9BQU9nQyxFQUFFOUIsSUFBSSxDQUFDZ0MsYUFBYSxDQUFDRCxFQUFFL0IsSUFBSTtZQUNwQztRQUNGLEtBQUs7WUFDSCxPQUFPNEIsT0FBT0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDO2dCQUNyQixNQUFNRSxRQUFRLElBQUlDLEtBQUtKLEVBQUVLLFVBQVUsSUFBSTtnQkFDdkMsTUFBTUMsUUFBUSxJQUFJRixLQUFLSCxFQUFFSSxVQUFVLElBQUk7Z0JBQ3ZDLE9BQU9DLE1BQU1DLE9BQU8sS0FBS0osTUFBTUksT0FBTztZQUN4QztRQUNGO1lBQ0UsT0FBT1Q7SUFDWDtBQUNGO0FBRUEsMEVBQTBFO0FBQ25FLGVBQWVVLGlCQUFpQkMsS0FBYSxFQUFFQyxLQUFhO0lBQ2pFLElBQUk7UUFDRixzQ0FBc0M7UUFDdEMsTUFBTSxFQUFFbkUsTUFBTW9FLFVBQVUsRUFBRW5FLE9BQU9vRSxXQUFXLEVBQUUsR0FBRyxNQUFNMUYsU0FDcER1QixJQUFJLENBQUMsV0FDTEMsTUFBTSxDQUFDO1FBQ1YsSUFBSWtFLGFBQWE7WUFDZjlELFFBQVFOLEtBQUssQ0FBQyxjQUFjb0U7WUFDNUIsT0FBTztRQUNUO1FBQ0EsTUFBTXJELFVBQVUsQ0FBQ29ELGNBQWMsRUFBRSxFQUFFRSxNQUFNLENBQUNDLENBQUFBLFNBQ3hDQyxNQUFNQyxPQUFPLENBQUNGLE9BQU9sQixXQUFXLEtBQUtrQixPQUFPbEIsV0FBVyxDQUFDcUIsSUFBSSxDQUFDLENBQUNDLE1BQWFBLElBQUl4RCxhQUFhLEtBQUsrQztRQUVuRyxLQUFLLE1BQU1LLFVBQVV2RCxRQUFTO1lBQzVCLE1BQU00RCxxQkFBcUIsQ0FBQ0wsT0FBT2xCLFdBQVcsSUFBSSxFQUFFLEVBQUV3QixHQUFHLENBQUMsQ0FBQ0YsTUFDekRBLElBQUl4RCxhQUFhLEtBQUsrQyxRQUFRO29CQUFFLEdBQUdTLEdBQUc7b0JBQUV4RCxlQUFlZ0Q7Z0JBQU0sSUFBSVE7WUFFbkUsTUFBTWhHLFNBQ0h1QixJQUFJLENBQUMsV0FDTFksTUFBTSxDQUFDO2dCQUFFdUMsYUFBYXVCO1lBQW1CLEdBQ3pDbEUsRUFBRSxDQUFDLE1BQU02RCxPQUFPOUQsRUFBRTtRQUN2QjtRQUNBLGtEQUFrRDtRQUNsRCxNQUFNcUUsWUFBWSxDQUFDVixjQUFjLEVBQUUsRUFBRUUsTUFBTSxDQUFDQyxDQUFBQSxTQUMxQ0MsTUFBTUMsT0FBTyxDQUFDRixPQUFPbEIsV0FBVyxLQUFLa0IsT0FBT2xCLFdBQVcsQ0FBQ3FCLElBQUksQ0FBQyxDQUFDQyxNQUFhQSxJQUFJeEQsYUFBYSxLQUFLK0M7UUFFbkcsSUFBSSxDQUFDWSxhQUFhQSxVQUFVMUQsTUFBTSxLQUFLLEdBQUc7WUFDeEMsTUFBTXpDLFNBQVN1QixJQUFJLENBQUMsc0JBQXNCbUIsTUFBTSxHQUFHWCxFQUFFLENBQUMsTUFBTXdEO1FBQzlEO1FBQ0F4RTtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9PLE9BQU87UUFDZE0sUUFBUU4sS0FBSyxDQUFDLHNCQUFzQkE7UUFDcEMsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9pbmdyZWRpZW50U3luYy50cz9jMDdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgUmVjaXBlSW5ncmVkaWVudCwgSW5ncmVkaWVudE1hc3RlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhXG4pO1xuXG5sZXQgdmVyc2lvbiA9IDA7XG5jb25zdCBsaXN0ZW5lcnM6ICgoKSA9PiB2b2lkKVtdID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbmdyZWRpZW50U3luYygpIHtcbiAgY29uc3QgWywgc2V0VGlja10gPSB1c2VTdGF0ZSgwKTtcbiAgZnVuY3Rpb24gb25TeW5jKCkgeyBzZXRUaWNrKHQgPT4gdCArIDEpOyB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGlzdGVuZXJzLnB1c2gob25TeW5jKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gbGlzdGVuZXJzLmluZGV4T2Yob25TeW5jKTtcbiAgICAgIGlmIChpZHggPiAtMSkgbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmlnZ2VySW5ncmVkaWVudFN5bmMoKSB7XG4gIHZlcnNpb24rKztcbiAgbGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oKSk7XG59XG5cbi8vIOyerOujjCDqsoDsg4kg7ZWo7IiYXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoSW5ncmVkaWVudHMocXVlcnk6IHN0cmluZywgbGltaXQ6IG51bWJlciA9IDEwKTogUHJvbWlzZTxJbmdyZWRpZW50TWFzdGVyW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2luZ3JlZGllbnRzX21hc3RlcicpXG4gICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgdW5pdCwgc2hvcF91cmwsIGlzX2Zhdm9yaXRlLCBjcmVhdGVkX2F0JylcbiAgICAgIC5pbGlrZSgnbmFtZScsIGAlJHtxdWVyeX0lYClcbiAgICAgIC5vcmRlcignaXNfZmF2b3JpdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSkgLy8g7KaQ6rKo7LC+6riwIOyerOujjOulvCDrqLzsoIAg7ZGc7IucXG4gICAgICAub3JkZXIoJ25hbWUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgLmxpbWl0KGxpbWl0KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign7J6s66OMIOqygOyDiSDsi6TtjKg6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDqsoDsg4kg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vIOyerOujjCDsg4HshLgg7KCV67O0IOyhsO2ajCDtlajsiJhcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRJbmdyZWRpZW50QnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxJbmdyZWRpZW50TWFzdGVyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1bml0LCBzaG9wX3VybCwgaXNfZmF2b3JpdGUsIGNyZWF0ZWRfYXQnKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7KGw7ZqMIOyLpO2MqDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7KGw7ZqMIOykkSDsmKTrpZg6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIOyerOujjCDsl4XrjbDsnbTtirgg7ZWo7IiYXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSW5ncmVkaWVudChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPEluZ3JlZGllbnRNYXN0ZXI+KTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxuICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign7J6s66OMIOyXheuNsOydtO2KuCDsi6TtjKg6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyaWdnZXJJbmdyZWRpZW50U3luYygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsl4XrjbDsnbTtirgg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIOyerOujjCDsgq3soJwg7ZWo7IiYICjri6Trpbgg66CI7Iuc7ZS87JeQ7IScIOyCrOyaqeuQmOyngCDslYrripQg6rK97Jqw7JeQ66eMKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluZ3JlZGllbnRJZlVudXNlZChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgLy8g7ZW064u5IOyerOujjOulvCDsgqzsmqntlZjripQg64uk66W4IOugiOyLnO2UvOqwgCDsnojripTsp4Ag7ZmV7J24XG4gICAgY29uc3QgeyBkYXRhOiByZWNpcGVzLCBlcnJvcjogcmVjaXBlc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3JlY2lwZXMnKVxuICAgICAgLnNlbGVjdCgnaW5ncmVkaWVudHMnKVxuICAgICAgLmNvbnRhaW5zKCdpbmdyZWRpZW50cycsIFt7IGluZ3JlZGllbnRfaWQ6IGlkIH1dKTtcblxuICAgIGlmIChyZWNpcGVzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+ugiOyLnO2UvCDsobDtmowg7Iuk7YyoOicsIHJlY2lwZXNFcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8g64uk66W4IOugiOyLnO2UvOyXkOyEnCDsgqzsmqnrkJjsp4Ag7JWK64qUIOqyveyasOyXkOunjCDsgq3soJxcbiAgICBpZiAoIXJlY2lwZXMgfHwgcmVjaXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsgq3soJwg7Iuk7YyoOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VySW5ncmVkaWVudFN5bmMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTsgLy8g64uk66W4IOugiOyLnO2UvOyXkOyEnCDsgqzsmqkg7KSRXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign7J6s66OMIOyCreygnCDspJEg7Jik66WYOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8g7J6s66OMIOymkOqyqOywvuq4sCDthqDquIAg7ZWo7IiYXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlSW5ncmVkaWVudEZhdm9yaXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICAvLyDtmITsnqwg7KaQ6rKo7LC+6riwIOyDge2DnCDsobDtmoxcbiAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgZ2V0SW5ncmVkaWVudEJ5SWQoaWQpO1xuICAgIGlmICghY3VycmVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgbmV3RmF2b3JpdGVTdGF0ZSA9ICFjdXJyZW50LmlzX2Zhdm9yaXRlO1xuXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgLnVwZGF0ZSh7IGlzX2Zhdm9yaXRlOiBuZXdGYXZvcml0ZVN0YXRlIH0pXG4gICAgICAuZXEoJ2lkJywgaWQpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7KaQ6rKo7LC+6riwIO2GoOq4gCDsi6TtjKg6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyaWdnZXJJbmdyZWRpZW50U3luYygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsppDqsqjssL7quLAg7Yag6riAIOykkSDsmKTrpZg6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyDsnqzro4zrqoXsnLzroZwg7J6s66OMIOywvuq4sCAo7KCV7ZmV7ZWcIOunpOy5rSlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kSW5ncmVkaWVudEJ5TmFtZShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPEluZ3JlZGllbnRNYXN0ZXIgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIHVuaXQsIHNob3BfdXJsLCBpc19mYXZvcml0ZSwgY3JlYXRlZF9hdCcpXG4gICAgICAuaWxpa2UoJ25hbWUnLCBuYW1lLnRyaW0oKSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgLy8g7J6s66OM6rCAIOyXhuuKlCDqsr3smrAgbnVsbCDrsJjtmZggKOyXkOufrOqwgCDslYTri5gpXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDqsoDsg4kg7Iuk7YyoOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDqsoDsg4kg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8g7IOIIOyerOujjCDsg53shLEg7ZWo7IiYXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW5ncmVkaWVudChpbmdyZWRpZW50OiBPbWl0PEluZ3JlZGllbnRNYXN0ZXIsICdpZCcgfCAnY3JlYXRlZF9hdCc+KTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIG5hbWU6IGluZ3JlZGllbnQubmFtZS50cmltKCksXG4gICAgICAgIHVuaXQ6IGluZ3JlZGllbnQudW5pdCB8fCAn6rCcJyxcbiAgICAgICAgc2hvcF91cmw6IGluZ3JlZGllbnQuc2hvcF91cmwgfHwgbnVsbCxcbiAgICAgICAgaXNfZmF2b3JpdGU6IGluZ3JlZGllbnQuaXNfZmF2b3JpdGUgfHwgZmFsc2VcbiAgICAgIH0pXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsg53shLEg7Iuk7YyoOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyaWdnZXJJbmdyZWRpZW50U3luYygpO1xuICAgIHJldHVybiBkYXRhLmlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsg53shLEg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8g7J6Q7KO8IOyCrOyaqeuQmOuKlCDsnqzro4wg7LaU7LKcIO2VqOyImFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBvcHVsYXJJbmdyZWRpZW50cyhsaW1pdDogbnVtYmVyID0gMTApOiBQcm9taXNlPEluZ3JlZGllbnRNYXN0ZXJbXT4ge1xuICB0cnkge1xuICAgIC8vIOymkOqyqOywvuq4sOuQnCDsnqzro4zrk6TsnYQg7Jqw7ISg7KCB7Jy866GcIOqwgOyguOyYpOq4sFxuICAgIGNvbnN0IHsgZGF0YTogZmF2b3JpdGVJbmdyZWRpZW50cywgZXJyb3I6IGZhdm9yaXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1bml0LCBzaG9wX3VybCwgaXNfZmF2b3JpdGUsIGNyZWF0ZWRfYXQnKVxuICAgICAgLmVxKCdpc19mYXZvcml0ZScsIHRydWUpXG4gICAgICAub3JkZXIoJ25hbWUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgLmxpbWl0KE1hdGguY2VpbChsaW1pdCAvIDIpKTtcblxuICAgIGlmIChmYXZvcml0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfsppDqsqjssL7quLAg7J6s66OMIOyhsO2ajCDsi6TtjKg6JywgZmF2b3JpdGVFcnJvcik7XG4gICAgfVxuXG4gICAgLy8g64KY66i47KeA64qUIOy1nOq3vCDsg53shLHrkJwg7J6s66OM65Ok66GcIOyxhOyasOq4sFxuICAgIGNvbnN0IHJlbWFpbmluZ0xpbWl0ID0gbGltaXQgLSAoZmF2b3JpdGVJbmdyZWRpZW50cz8ubGVuZ3RoIHx8IDApO1xuICAgIGxldCByZWNlbnRJbmdyZWRpZW50czogSW5ncmVkaWVudE1hc3RlcltdID0gW107XG4gICAgXG4gICAgaWYgKHJlbWFpbmluZ0xpbWl0ID4gMCkge1xuICAgICAgY29uc3QgeyBkYXRhOiByZWNlbnQsIGVycm9yOiByZWNlbnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2luZ3JlZGllbnRzX21hc3RlcicpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1bml0LCBzaG9wX3VybCwgaXNfZmF2b3JpdGUsIGNyZWF0ZWRfYXQnKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KHJlbWFpbmluZ0xpbWl0KTtcblxuICAgICAgaWYgKHJlY2VudEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+y1nOq3vCDsnqzro4wg7KGw7ZqMIOyLpO2MqDonLCByZWNlbnRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNlbnRJbmdyZWRpZW50cyA9IHJlY2VudCB8fCBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDsppDqsqjssL7quLAg7J6s66OM7JmAIOy1nOq3vCDsnqzro4zrpbwg7ZWp7LmY6rOgIOykkeuztSDsoJzqsbBcbiAgICBjb25zdCBhbGxJbmdyZWRpZW50cyA9IFsuLi4oZmF2b3JpdGVJbmdyZWRpZW50cyB8fCBbXSksIC4uLnJlY2VudEluZ3JlZGllbnRzXTtcbiAgICBjb25zdCB1bmlxdWVJbmdyZWRpZW50cyA9IGFsbEluZ3JlZGllbnRzLnJlZHVjZSgoYWNjOiBJbmdyZWRpZW50TWFzdGVyW10sIGN1cnJlbnQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0cyA9IGFjYy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gY3VycmVudC5pZCk7XG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICBhY2MucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHVuaXF1ZUluZ3JlZGllbnRzLnNsaWNlKDAsIGxpbWl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnbjquLAg7J6s66OMIOyhsO2ajCDspJEg7Jik66WYOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8g7J6s66OMIOqygOyDiSDqsrDqs7wg7KCV66CsIO2VqOyImFxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRJbmdyZWRpZW50cyhpbmdyZWRpZW50czogSW5ncmVkaWVudE1hc3RlcltdLCBzb3J0Qnk6ICduYW1lJyB8ICdmYXZvcml0ZScgfCAncmVjZW50JyA9ICdmYXZvcml0ZScpOiBJbmdyZWRpZW50TWFzdGVyW10ge1xuICBjb25zdCBzb3J0ZWQgPSBbLi4uaW5ncmVkaWVudHNdO1xuICBcbiAgc3dpdGNoIChzb3J0QnkpIHtcbiAgICBjYXNlICduYW1lJzpcbiAgICAgIHJldHVybiBzb3J0ZWQuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG4gICAgY2FzZSAnZmF2b3JpdGUnOlxuICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLmlzX2Zhdm9yaXRlICYmICFiLmlzX2Zhdm9yaXRlKSByZXR1cm4gLTE7XG4gICAgICAgIGlmICghYS5pc19mYXZvcml0ZSAmJiBiLmlzX2Zhdm9yaXRlKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gICAgICB9KTtcbiAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGVBID0gbmV3IERhdGUoYS5jcmVhdGVkX2F0IHx8IDApO1xuICAgICAgICBjb25zdCBkYXRlQiA9IG5ldyBEYXRlKGIuY3JlYXRlZF9hdCB8fCAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGVCLmdldFRpbWUoKSAtIGRhdGVBLmdldFRpbWUoKTtcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc29ydGVkO1xuICB9XG59IFxuXG4vLyDrkZAg7J6s66OM66W8IO2Gte2VqShtZXJnZSntlZjripQg7ZWo7IiYOiBvbGRJZOydmCDrqqjrk6Ag66CI7Iuc7ZS866W8IG5ld0lk66GcIOq1kOyytCwgb2xkSWTqsIAg642UIOydtOyDgSDsgqzsmqnrkJjsp4Ag7JWK7Jy866m0IOyCreygnFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lcmdlSW5ncmVkaWVudHMob2xkSWQ6IHN0cmluZywgbmV3SWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIC8vIDEuIOuqqOuToCDroIjsi5ztlLzrpbwg67aI65+s7JmA7IScIG9sZElk6rCAIO2PrO2VqOuQnCDroIjsi5ztlLzrp4wg7ZWE7YSw66eBXG4gICAgY29uc3QgeyBkYXRhOiBhbGxSZWNpcGVzLCBlcnJvcjogcmVjaXBlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncmVjaXBlcycpXG4gICAgICAuc2VsZWN0KCdpZCwgaW5ncmVkaWVudHMnKTtcbiAgICBpZiAocmVjaXBlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+ugiOyLnO2UvCDsobDtmowg7Iuk7YyoOicsIHJlY2lwZUVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVjaXBlcyA9IChhbGxSZWNpcGVzIHx8IFtdKS5maWx0ZXIocmVjaXBlID0+XG4gICAgICBBcnJheS5pc0FycmF5KHJlY2lwZS5pbmdyZWRpZW50cykgJiYgcmVjaXBlLmluZ3JlZGllbnRzLnNvbWUoKGluZzogYW55KSA9PiBpbmcuaW5ncmVkaWVudF9pZCA9PT0gb2xkSWQpXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHJlY2lwZSBvZiByZWNpcGVzKSB7XG4gICAgICBjb25zdCB1cGRhdGVkSW5ncmVkaWVudHMgPSAocmVjaXBlLmluZ3JlZGllbnRzIHx8IFtdKS5tYXAoKGluZzogYW55KSA9PlxuICAgICAgICBpbmcuaW5ncmVkaWVudF9pZCA9PT0gb2xkSWQgPyB7IC4uLmluZywgaW5ncmVkaWVudF9pZDogbmV3SWQgfSA6IGluZ1xuICAgICAgKTtcbiAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyZWNpcGVzJylcbiAgICAgICAgLnVwZGF0ZSh7IGluZ3JlZGllbnRzOiB1cGRhdGVkSW5ncmVkaWVudHMgfSlcbiAgICAgICAgLmVxKCdpZCcsIHJlY2lwZS5pZCk7XG4gICAgfVxuICAgIC8vIDIuIG9sZElk6rCAIOuNlCDsnbTsg4Eg7IKs7Jqp65CY7KeAIOyViuycvOuptCBpbmdyZWRpZW50c19tYXN0ZXLsl5DshJwg7IKt7KCcXG4gICAgY29uc3Qgc3RpbGxVc2VkID0gKGFsbFJlY2lwZXMgfHwgW10pLmZpbHRlcihyZWNpcGUgPT5cbiAgICAgIEFycmF5LmlzQXJyYXkocmVjaXBlLmluZ3JlZGllbnRzKSAmJiByZWNpcGUuaW5ncmVkaWVudHMuc29tZSgoaW5nOiBhbnkpID0+IGluZy5pbmdyZWRpZW50X2lkID09PSBvbGRJZClcbiAgICApO1xuICAgIGlmICghc3RpbGxVc2VkIHx8IHN0aWxsVXNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ2luZ3JlZGllbnRzX21hc3RlcicpLmRlbGV0ZSgpLmVxKCdpZCcsIG9sZElkKTtcbiAgICB9XG4gICAgdHJpZ2dlckluZ3JlZGllbnRTeW5jKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign7J6s66OMIO2Gte2VqShtZXJnZSkg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwidmVyc2lvbiIsImxpc3RlbmVycyIsInVzZUluZ3JlZGllbnRTeW5jIiwic2V0VGljayIsIm9uU3luYyIsInQiLCJwdXNoIiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsInRyaWdnZXJJbmdyZWRpZW50U3luYyIsImZvckVhY2giLCJmbiIsInNlYXJjaEluZ3JlZGllbnRzIiwicXVlcnkiLCJsaW1pdCIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJpbGlrZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiY29uc29sZSIsImdldEluZ3JlZGllbnRCeUlkIiwiaWQiLCJlcSIsInNpbmdsZSIsInVwZGF0ZUluZ3JlZGllbnQiLCJ1cGRhdGVzIiwidXBkYXRlIiwiZGVsZXRlSW5ncmVkaWVudElmVW51c2VkIiwicmVjaXBlcyIsInJlY2lwZXNFcnJvciIsImNvbnRhaW5zIiwiaW5ncmVkaWVudF9pZCIsImxlbmd0aCIsImRlbGV0ZSIsInRvZ2dsZUluZ3JlZGllbnRGYXZvcml0ZSIsImN1cnJlbnQiLCJuZXdGYXZvcml0ZVN0YXRlIiwiaXNfZmF2b3JpdGUiLCJmaW5kSW5ncmVkaWVudEJ5TmFtZSIsIm5hbWUiLCJ0cmltIiwiY29kZSIsImNyZWF0ZUluZ3JlZGllbnQiLCJpbmdyZWRpZW50IiwiaW5zZXJ0IiwidW5pdCIsInNob3BfdXJsIiwiZ2V0UG9wdWxhckluZ3JlZGllbnRzIiwiZmF2b3JpdGVJbmdyZWRpZW50cyIsImZhdm9yaXRlRXJyb3IiLCJNYXRoIiwiY2VpbCIsInJlbWFpbmluZ0xpbWl0IiwicmVjZW50SW5ncmVkaWVudHMiLCJyZWNlbnQiLCJyZWNlbnRFcnJvciIsImFsbEluZ3JlZGllbnRzIiwidW5pcXVlSW5ncmVkaWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJleGlzdHMiLCJmaW5kIiwiaXRlbSIsInNsaWNlIiwic29ydEluZ3JlZGllbnRzIiwiaW5ncmVkaWVudHMiLCJzb3J0QnkiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiZGF0ZUEiLCJEYXRlIiwiY3JlYXRlZF9hdCIsImRhdGVCIiwiZ2V0VGltZSIsIm1lcmdlSW5ncmVkaWVudHMiLCJvbGRJZCIsIm5ld0lkIiwiYWxsUmVjaXBlcyIsInJlY2lwZUVycm9yIiwiZmlsdGVyIiwicmVjaXBlIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImluZyIsInVwZGF0ZWRJbmdyZWRpZW50cyIsIm1hcCIsInN0aWxsVXNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ingredientSync.ts\n"));

/***/ })

});