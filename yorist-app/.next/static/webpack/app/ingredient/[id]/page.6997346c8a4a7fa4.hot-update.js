"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/ingredient/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/ingredientSync.ts":
/*!***********************************!*\
  !*** ./src/lib/ingredientSync.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createIngredient: function() { return /* binding */ createIngredient; },\n/* harmony export */   deleteIngredientIfUnused: function() { return /* binding */ deleteIngredientIfUnused; },\n/* harmony export */   findIngredientByName: function() { return /* binding */ findIngredientByName; },\n/* harmony export */   getIngredientById: function() { return /* binding */ getIngredientById; },\n/* harmony export */   getPopularIngredients: function() { return /* binding */ getPopularIngredients; },\n/* harmony export */   mergeIngredients: function() { return /* binding */ mergeIngredients; },\n/* harmony export */   searchIngredients: function() { return /* binding */ searchIngredients; },\n/* harmony export */   sortIngredients: function() { return /* binding */ sortIngredients; },\n/* harmony export */   toggleIngredientFavorite: function() { return /* binding */ toggleIngredientFavorite; },\n/* harmony export */   triggerIngredientSync: function() { return /* binding */ triggerIngredientSync; },\n/* harmony export */   updateIngredient: function() { return /* binding */ updateIngredient; },\n/* harmony export */   useIngredientSync: function() { return /* binding */ useIngredientSync; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://rshosgiwnqcvwfnkqdwc.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJzaG9zZ2l3bnFjdndmbmtxZHdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE2MzMxNjEsImV4cCI6MjA2NzIwOTE2MX0.9yrX80F0-3w0H8u3Qx449oYRpD4vA1wEjEYP7mdylGg\");\nlet version = 0;\nconst listeners = [];\nfunction useIngredientSync() {\n    const [, setTick] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    function onSync() {\n        setTick((t)=>t + 1);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        listeners.push(onSync);\n        return ()=>{\n            const idx = listeners.indexOf(onSync);\n            if (idx > -1) listeners.splice(idx, 1);\n        };\n    }, []);\n    return version;\n}\nfunction triggerIngredientSync() {\n    version++;\n    listeners.forEach((fn)=>fn());\n}\n// 재료 검색 함수\nasync function searchIngredients(query) {\n    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").ilike(\"name\", \"%\".concat(query, \"%\")).order(\"is_favorite\", {\n            ascending: false\n        }) // 즐겨찾기 재료를 먼저 표시\n        .order(\"name\", {\n            ascending: true\n        }).limit(limit);\n        if (error) {\n            console.error(\"재료 검색 실패:\", error);\n            return [];\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"재료 검색 중 오류:\", error);\n        return [];\n    }\n}\n// 재료 상세 정보 조회 함수\nasync function getIngredientById(id) {\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").eq(\"id\", id).single();\n        if (error) {\n            console.error(\"재료 조회 실패:\", error);\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error(\"재료 조회 중 오류:\", error);\n        return null;\n    }\n}\n// 재료 업데이트 함수\nasync function updateIngredient(id, updates) {\n    try {\n        const { error } = await supabase.from(\"ingredients_master\").update(updates).eq(\"id\", id);\n        if (error) {\n            console.error(\"재료 업데이트 실패:\", error);\n            return false;\n        }\n        triggerIngredientSync();\n        return true;\n    } catch (error) {\n        console.error(\"재료 업데이트 중 오류:\", error);\n        return false;\n    }\n}\n// 재료 삭제 함수 (다른 레시피에서 사용되지 않는 경우에만)\nasync function deleteIngredientIfUnused(id) {\n    try {\n        // 해당 재료를 사용하는 다른 레시피가 있는지 확인\n        const { data: recipes, error: recipesError } = await supabase.from(\"recipes\").select(\"ingredients\").contains(\"ingredients\", [\n            {\n                ingredient_id: id\n            }\n        ]);\n        if (recipesError) {\n            console.error(\"레시피 조회 실패:\", recipesError);\n            return false;\n        }\n        // 다른 레시피에서 사용되지 않는 경우에만 삭제\n        if (!recipes || recipes.length === 0) {\n            const { error } = await supabase.from(\"ingredients_master\").delete().eq(\"id\", id);\n            if (error) {\n                console.error(\"재료 삭제 실패:\", error);\n                return false;\n            }\n            triggerIngredientSync();\n            return true;\n        }\n        return false; // 다른 레시피에서 사용 중\n    } catch (error) {\n        console.error(\"재료 삭제 중 오류:\", error);\n        return false;\n    }\n}\n// 재료 즐겨찾기 토글 함수\nasync function toggleIngredientFavorite(id) {\n    try {\n        // 현재 즐겨찾기 상태 조회\n        const current = await getIngredientById(id);\n        if (!current) return false;\n        const newFavoriteState = !current.is_favorite;\n        const { error } = await supabase.from(\"ingredients_master\").update({\n            is_favorite: newFavoriteState\n        }).eq(\"id\", id);\n        if (error) {\n            console.error(\"재료 즐겨찾기 토글 실패:\", error);\n            return false;\n        }\n        triggerIngredientSync();\n        return true;\n    } catch (error) {\n        console.error(\"재료 즐겨찾기 토글 중 오류:\", error);\n        return false;\n    }\n}\n// 재료명으로 재료 찾기 (정확한 매칭)\nasync function findIngredientByName(name) {\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").ilike(\"name\", name.trim()).single();\n        if (error) {\n            // 재료가 없는 경우 null 반환 (에러가 아님)\n            if (error.code === \"PGRST116\") {\n                return null;\n            }\n            console.error(\"재료 검색 실패:\", error);\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error(\"재료 검색 중 오류:\", error);\n        return null;\n    }\n}\n// 새 재료 생성 함수\nasync function createIngredient(ingredient) {\n    try {\n        const { data, error } = await supabase.from(\"ingredients_master\").insert({\n            name: ingredient.name.trim(),\n            unit: ingredient.unit || \"개\",\n            shop_url: ingredient.shop_url || null,\n            is_favorite: ingredient.is_favorite || false\n        }).select(\"id\").single();\n        if (error) {\n            console.error(\"재료 생성 실패:\", error);\n            return null;\n        }\n        triggerIngredientSync();\n        return data.id;\n    } catch (error) {\n        console.error(\"재료 생성 중 오류:\", error);\n        return null;\n    }\n}\n// 자주 사용되는 재료 추천 함수\nasync function getPopularIngredients() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n    try {\n        // 즐겨찾기된 재료들을 우선적으로 가져오기\n        const { data: favoriteIngredients, error: favoriteError } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").eq(\"is_favorite\", true).order(\"name\", {\n            ascending: true\n        }).limit(Math.ceil(limit / 2));\n        if (favoriteError) {\n            console.error(\"즐겨찾기 재료 조회 실패:\", favoriteError);\n        }\n        // 나머지는 최근 생성된 재료들로 채우기\n        const remainingLimit = limit - ((favoriteIngredients === null || favoriteIngredients === void 0 ? void 0 : favoriteIngredients.length) || 0);\n        let recentIngredients = [];\n        if (remainingLimit > 0) {\n            const { data: recent, error: recentError } = await supabase.from(\"ingredients_master\").select(\"id, name, unit, shop_url, is_favorite, created_at\").order(\"created_at\", {\n                ascending: false\n            }).limit(remainingLimit);\n            if (recentError) {\n                console.error(\"최근 재료 조회 실패:\", recentError);\n            } else {\n                recentIngredients = recent || [];\n            }\n        }\n        // 즐겨찾기 재료와 최근 재료를 합치고 중복 제거\n        const allIngredients = [\n            ...favoriteIngredients || [],\n            ...recentIngredients\n        ];\n        const uniqueIngredients = allIngredients.reduce((acc, current)=>{\n            const exists = acc.find((item)=>item.id === current.id);\n            if (!exists) {\n                acc.push(current);\n            }\n            return acc;\n        }, []);\n        return uniqueIngredients.slice(0, limit);\n    } catch (error) {\n        console.error(\"인기 재료 조회 중 오류:\", error);\n        return [];\n    }\n}\n// 재료 검색 결과 정렬 함수\nfunction sortIngredients(ingredients) {\n    let sortBy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"favorite\";\n    const sorted = [\n        ...ingredients\n    ];\n    switch(sortBy){\n        case \"name\":\n            return sorted.sort((a, b)=>a.name.localeCompare(b.name));\n        case \"favorite\":\n            return sorted.sort((a, b)=>{\n                if (a.is_favorite && !b.is_favorite) return -1;\n                if (!a.is_favorite && b.is_favorite) return 1;\n                return a.name.localeCompare(b.name);\n            });\n        case \"recent\":\n            return sorted.sort((a, b)=>{\n                const dateA = new Date(a.created_at || 0);\n                const dateB = new Date(b.created_at || 0);\n                return dateB.getTime() - dateA.getTime();\n            });\n        default:\n            return sorted;\n    }\n}\n// 두 재료를 통합(merge)하는 함수: oldId의 모든 레시피를 newId로 교체, oldId가 더 이상 사용되지 않으면 삭제\nasync function mergeIngredients(oldId, newId) {\n    try {\n        // 1. 모든 레시피에서 oldId를 newId로 교체\n        const { data: recipes, error: recipeError } = await supabase.from(\"recipes\").select(\"id, ingredients\").contains(\"ingredients\", [\n            {\n                ingredient_id: oldId\n            }\n        ]);\n        if (recipeError) {\n            console.error(\"레시피 조회 실패:\", recipeError);\n            return false;\n        }\n        for (const recipe of recipes || []){\n            const updatedIngredients = (recipe.ingredients || []).map((ing)=>ing.ingredient_id === oldId ? {\n                    ...ing,\n                    ingredient_id: newId\n                } : ing);\n            await supabase.from(\"recipes\").update({\n                ingredients: updatedIngredients\n            }).eq(\"id\", recipe.id);\n        }\n        // 2. oldId가 더 이상 사용되지 않으면 ingredients_master에서 삭제\n        const { data: stillUsed } = await supabase.from(\"recipes\").select(\"id\").contains(\"ingredients\", [\n            {\n                ingredient_id: oldId\n            }\n        ]);\n        if (!stillUsed || stillUsed.length === 0) {\n            await supabase.from(\"ingredients_master\").delete().eq(\"id\", oldId);\n        }\n        triggerIngredientSync();\n        return true;\n    } catch (error) {\n        console.error(\"재료 통합(merge) 중 오류:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaW5ncmVkaWVudFN5bmMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ1M7QUFHckQsTUFBTUcsV0FBV0QsbUVBQVlBLENBQzNCRSwwQ0FBb0MsRUFDcENBLGtOQUF5QztBQUczQyxJQUFJSSxVQUFVO0FBQ2QsTUFBTUMsWUFBNEIsRUFBRTtBQUU3QixTQUFTQztJQUNkLE1BQU0sR0FBR0MsUUFBUSxHQUFHViwrQ0FBUUEsQ0FBQztJQUM3QixTQUFTVztRQUFXRCxRQUFRRSxDQUFBQSxJQUFLQSxJQUFJO0lBQUk7SUFDekNiLGdEQUFTQSxDQUFDO1FBQ1JTLFVBQVVLLElBQUksQ0FBQ0Y7UUFDZixPQUFPO1lBQ0wsTUFBTUcsTUFBTU4sVUFBVU8sT0FBTyxDQUFDSjtZQUM5QixJQUFJRyxNQUFNLENBQUMsR0FBR04sVUFBVVEsTUFBTSxDQUFDRixLQUFLO1FBQ3RDO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBT1A7QUFDVDtBQUVPLFNBQVNVO0lBQ2RWO0lBQ0FDLFVBQVVVLE9BQU8sQ0FBQ0MsQ0FBQUEsS0FBTUE7QUFDMUI7QUFFQSxXQUFXO0FBQ0osZUFBZUMsa0JBQWtCQyxLQUFhO1FBQUVDLFFBQUFBLGlFQUFnQjtJQUNyRSxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU10QixTQUMzQnVCLElBQUksQ0FBQyxzQkFDTEMsTUFBTSxDQUFDLHFEQUNQQyxLQUFLLENBQUMsUUFBUSxJQUFVLE9BQU5OLE9BQU0sTUFDeEJPLEtBQUssQ0FBQyxlQUFlO1lBQUVDLFdBQVc7UUFBTSxHQUFHLGlCQUFpQjtTQUM1REQsS0FBSyxDQUFDLFFBQVE7WUFBRUMsV0FBVztRQUFLLEdBQ2hDUCxLQUFLLENBQUNBO1FBRVQsSUFBSUUsT0FBTztZQUNUTSxRQUFRTixLQUFLLENBQUMsYUFBYUE7WUFDM0IsT0FBTyxFQUFFO1FBQ1g7UUFFQSxPQUFPRCxR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QUFNO1NBQUU7UUFDckQsSUFBSUUsYUFBYTtZQUNmN0QsUUFBUU4sS0FBSyxDQUFDLGNBQWNtRTtZQUM1QixPQUFPO1FBQ1Q7UUFDQSxLQUFLLE1BQU1DLFVBQVVyRCxXQUFXLEVBQUUsQ0FBRTtZQUNsQyxNQUFNc0QscUJBQXFCLENBQUNELE9BQU9oQixXQUFXLElBQUksRUFBRSxFQUFFa0IsR0FBRyxDQUFDLENBQUNDLE1BQ3pEQSxJQUFJckQsYUFBYSxLQUFLK0MsUUFBUTtvQkFBRSxHQUFHTSxHQUFHO29CQUFFckQsZUFBZWdEO2dCQUFNLElBQUlLO1lBRW5FLE1BQU03RixTQUNIdUIsSUFBSSxDQUFDLFdBQ0xZLE1BQU0sQ0FBQztnQkFBRXVDLGFBQWFpQjtZQUFtQixHQUN6QzVELEVBQUUsQ0FBQyxNQUFNMkQsT0FBTzVELEVBQUU7UUFDdkI7UUFDQSxrREFBa0Q7UUFDbEQsTUFBTSxFQUFFVCxNQUFNeUUsU0FBUyxFQUFFLEdBQUcsTUFBTTlGLFNBQy9CdUIsSUFBSSxDQUFDLFdBQ0xDLE1BQU0sQ0FBQyxNQUNQZSxRQUFRLENBQUMsZUFBZTtZQUFDO2dCQUFFQyxlQUFlK0M7WUFBTTtTQUFFO1FBQ3JELElBQUksQ0FBQ08sYUFBYUEsVUFBVXJELE1BQU0sS0FBSyxHQUFHO1lBQ3hDLE1BQU16QyxTQUFTdUIsSUFBSSxDQUFDLHNCQUFzQm1CLE1BQU0sR0FBR1gsRUFBRSxDQUFDLE1BQU13RDtRQUM5RDtRQUNBeEU7UUFDQSxPQUFPO0lBQ1QsRUFBRSxPQUFPTyxPQUFPO1FBQ2RNLFFBQVFOLEtBQUssQ0FBQyxzQkFBc0JBO1FBQ3BDLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvaW5ncmVkaWVudFN5bmMudHM/YzA3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IFJlY2lwZUluZ3JlZGllbnQsIEluZ3JlZGllbnRNYXN0ZXIgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCEsXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIVxuKTtcblxubGV0IHZlcnNpb24gPSAwO1xuY29uc3QgbGlzdGVuZXJzOiAoKCkgPT4gdm9pZClbXSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5ncmVkaWVudFN5bmMoKSB7XG4gIGNvbnN0IFssIHNldFRpY2tdID0gdXNlU3RhdGUoMCk7XG4gIGZ1bmN0aW9uIG9uU3luYygpIHsgc2V0VGljayh0ID0+IHQgKyAxKTsgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxpc3RlbmVycy5wdXNoKG9uU3luYyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKG9uU3luYyk7XG4gICAgICBpZiAoaWR4ID4gLTEpIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckluZ3JlZGllbnRTeW5jKCkge1xuICB2ZXJzaW9uKys7XG4gIGxpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKCkpO1xufVxuXG4vLyDsnqzro4wg6rKA7IOJIO2VqOyImFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaEluZ3JlZGllbnRzKHF1ZXJ5OiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMCk6IFByb21pc2U8SW5ncmVkaWVudE1hc3RlcltdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIHVuaXQsIHNob3BfdXJsLCBpc19mYXZvcml0ZSwgY3JlYXRlZF9hdCcpXG4gICAgICAuaWxpa2UoJ25hbWUnLCBgJSR7cXVlcnl9JWApXG4gICAgICAub3JkZXIoJ2lzX2Zhdm9yaXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pIC8vIOymkOqyqOywvuq4sCDsnqzro4zrpbwg66i87KCAIO2RnOyLnFxuICAgICAgLm9yZGVyKCduYW1lJywgeyBhc2NlbmRpbmc6IHRydWUgfSlcbiAgICAgIC5saW1pdChsaW1pdCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDqsoDsg4kg7Iuk7YyoOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg6rKA7IOJIOykkSDsmKTrpZg6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyDsnqzro4wg7IOB7IS4IOygleuztCDsobDtmowg7ZWo7IiYXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ncmVkaWVudEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8SW5ncmVkaWVudE1hc3RlciB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2luZ3JlZGllbnRzX21hc3RlcicpXG4gICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgdW5pdCwgc2hvcF91cmwsIGlzX2Zhdm9yaXRlLCBjcmVhdGVkX2F0JylcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign7J6s66OMIOyhsO2ajCDsi6TtjKg6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign7J6s66OMIOyhsO2ajCDspJEg7Jik66WYOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyDsnqzro4wg7JeF642w7J207Yq4IO2VqOyImFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUluZ3JlZGllbnQoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxJbmdyZWRpZW50TWFzdGVyPik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgIC51cGRhdGUodXBkYXRlcylcbiAgICAgIC5lcSgnaWQnLCBpZCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsl4XrjbDsnbTtirgg7Iuk7YyoOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cmlnZ2VySW5ncmVkaWVudFN5bmMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7JeF642w7J207Yq4IOykkSDsmKTrpZg6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyDsnqzro4wg7IKt7KCcIO2VqOyImCAo64uk66W4IOugiOyLnO2UvOyXkOyEnCDsgqzsmqnrkJjsp4Ag7JWK64qUIOqyveyasOyXkOunjClcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVJbmdyZWRpZW50SWZVbnVzZWQoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIC8vIO2VtOuLuSDsnqzro4zrpbwg7IKs7Jqp7ZWY64qUIOuLpOuluCDroIjsi5ztlLzqsIAg7J6I64qU7KeAIO2ZleyduFxuICAgIGNvbnN0IHsgZGF0YTogcmVjaXBlcywgZXJyb3I6IHJlY2lwZXNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdyZWNpcGVzJylcbiAgICAgIC5zZWxlY3QoJ2luZ3JlZGllbnRzJylcbiAgICAgIC5jb250YWlucygnaW5ncmVkaWVudHMnLCBbeyBpbmdyZWRpZW50X2lkOiBpZCB9XSk7XG5cbiAgICBpZiAocmVjaXBlc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfroIjsi5ztlLwg7KGw7ZqMIOyLpO2MqDonLCByZWNpcGVzRXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOuLpOuluCDroIjsi5ztlLzsl5DshJwg7IKs7Jqp65CY7KeAIOyViuuKlCDqsr3smrDsl5Drp4wg7IKt7KCcXG4gICAgaWYgKCFyZWNpcGVzIHx8IHJlY2lwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBpZCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7IKt7KCcIOyLpO2MqDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckluZ3JlZGllbnRTeW5jKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7IC8vIOuLpOuluCDroIjsi5ztlLzsl5DshJwg7IKs7JqpIOykkVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+yerOujjCDsgq3soJwg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIOyerOujjCDsppDqsqjssL7quLAg7Yag6riAIO2VqOyImFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZUluZ3JlZGllbnRGYXZvcml0ZShpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgLy8g7ZiE7J6sIOymkOqyqOywvuq4sCDsg4Htg5wg7KGw7ZqMXG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IGdldEluZ3JlZGllbnRCeUlkKGlkKTtcbiAgICBpZiAoIWN1cnJlbnQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IG5ld0Zhdm9yaXRlU3RhdGUgPSAhY3VycmVudC5pc19mYXZvcml0ZTtcblxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgIC51cGRhdGUoeyBpc19mYXZvcml0ZTogbmV3RmF2b3JpdGVTdGF0ZSB9KVxuICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign7J6s66OMIOymkOqyqOywvuq4sCDthqDquIAg7Iuk7YyoOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cmlnZ2VySW5ncmVkaWVudFN5bmMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7KaQ6rKo7LC+6riwIO2GoOq4gCDspJEg7Jik66WYOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8g7J6s66OM66qF7Jy866GcIOyerOujjCDssL7quLAgKOygle2Zle2VnCDrp6Tsua0pXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZEluZ3JlZGllbnRCeU5hbWUobmFtZTogc3RyaW5nKTogUHJvbWlzZTxJbmdyZWRpZW50TWFzdGVyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1bml0LCBzaG9wX3VybCwgaXNfZmF2b3JpdGUsIGNyZWF0ZWRfYXQnKVxuICAgICAgLmlsaWtlKCduYW1lJywgbmFtZS50cmltKCkpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIC8vIOyerOujjOqwgCDsl4bripQg6rK97JqwIG51bGwg67CY7ZmYICjsl5Drn6zqsIAg7JWE64uYKVxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg6rKA7IOJIOyLpO2MqDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg6rKA7IOJIOykkSDsmKTrpZg6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIOyDiCDsnqzro4wg7IOd7ISxIO2VqOyImFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUluZ3JlZGllbnQoaW5ncmVkaWVudDogT21pdDxJbmdyZWRpZW50TWFzdGVyLCAnaWQnIHwgJ2NyZWF0ZWRfYXQnPik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJylcbiAgICAgIC5pbnNlcnQoe1xuICAgICAgICBuYW1lOiBpbmdyZWRpZW50Lm5hbWUudHJpbSgpLFxuICAgICAgICB1bml0OiBpbmdyZWRpZW50LnVuaXQgfHwgJ+qwnCcsXG4gICAgICAgIHNob3BfdXJsOiBpbmdyZWRpZW50LnNob3BfdXJsIHx8IG51bGwsXG4gICAgICAgIGlzX2Zhdm9yaXRlOiBpbmdyZWRpZW50LmlzX2Zhdm9yaXRlIHx8IGZhbHNlXG4gICAgICB9KVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7IOd7ISxIOyLpO2MqDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cmlnZ2VySW5ncmVkaWVudFN5bmMoKTtcbiAgICByZXR1cm4gZGF0YS5pZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7IOd7ISxIOykkSDsmKTrpZg6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIOyekOyjvCDsgqzsmqnrkJjripQg7J6s66OMIOy2lOyynCDtlajsiJhcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQb3B1bGFySW5ncmVkaWVudHMobGltaXQ6IG51bWJlciA9IDEwKTogUHJvbWlzZTxJbmdyZWRpZW50TWFzdGVyW10+IHtcbiAgdHJ5IHtcbiAgICAvLyDsppDqsqjssL7quLDrkJwg7J6s66OM65Ok7J2EIOyasOyEoOyggeycvOuhnCDqsIDsoLjsmKTquLBcbiAgICBjb25zdCB7IGRhdGE6IGZhdm9yaXRlSW5ncmVkaWVudHMsIGVycm9yOiBmYXZvcml0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2luZ3JlZGllbnRzX21hc3RlcicpXG4gICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgdW5pdCwgc2hvcF91cmwsIGlzX2Zhdm9yaXRlLCBjcmVhdGVkX2F0JylcbiAgICAgIC5lcSgnaXNfZmF2b3JpdGUnLCB0cnVlKVxuICAgICAgLm9yZGVyKCduYW1lJywgeyBhc2NlbmRpbmc6IHRydWUgfSlcbiAgICAgIC5saW1pdChNYXRoLmNlaWwobGltaXQgLyAyKSk7XG5cbiAgICBpZiAoZmF2b3JpdGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign7KaQ6rKo7LC+6riwIOyerOujjCDsobDtmowg7Iuk7YyoOicsIGZhdm9yaXRlRXJyb3IpO1xuICAgIH1cblxuICAgIC8vIOuCmOuouOyngOuKlCDstZzqt7wg7IOd7ISx65CcIOyerOujjOuTpOuhnCDssYTsmrDquLBcbiAgICBjb25zdCByZW1haW5pbmdMaW1pdCA9IGxpbWl0IC0gKGZhdm9yaXRlSW5ncmVkaWVudHM/Lmxlbmd0aCB8fCAwKTtcbiAgICBsZXQgcmVjZW50SW5ncmVkaWVudHM6IEluZ3JlZGllbnRNYXN0ZXJbXSA9IFtdO1xuICAgIFxuICAgIGlmIChyZW1haW5pbmdMaW1pdCA+IDApIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcmVjZW50LCBlcnJvcjogcmVjZW50RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdpbmdyZWRpZW50c19tYXN0ZXInKVxuICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgdW5pdCwgc2hvcF91cmwsIGlzX2Zhdm9yaXRlLCBjcmVhdGVkX2F0JylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdChyZW1haW5pbmdMaW1pdCk7XG5cbiAgICAgIGlmIChyZWNlbnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfstZzqt7wg7J6s66OMIOyhsO2ajCDsi6TtjKg6JywgcmVjZW50RXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjZW50SW5ncmVkaWVudHMgPSByZWNlbnQgfHwgW107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g7KaQ6rKo7LC+6riwIOyerOujjOyZgCDstZzqt7wg7J6s66OM66W8IO2Vqey5mOqzoCDspJHrs7Ug7KCc6rGwXG4gICAgY29uc3QgYWxsSW5ncmVkaWVudHMgPSBbLi4uKGZhdm9yaXRlSW5ncmVkaWVudHMgfHwgW10pLCAuLi5yZWNlbnRJbmdyZWRpZW50c107XG4gICAgY29uc3QgdW5pcXVlSW5ncmVkaWVudHMgPSBhbGxJbmdyZWRpZW50cy5yZWR1Y2UoKGFjYzogSW5ncmVkaWVudE1hc3RlcltdLCBjdXJyZW50KSA9PiB7XG4gICAgICBjb25zdCBleGlzdHMgPSBhY2MuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGN1cnJlbnQuaWQpO1xuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgYWNjLnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB1bmlxdWVJbmdyZWRpZW50cy5zbGljZSgwLCBsaW1pdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign7J246riwIOyerOujjCDsobDtmowg7KSRIOyYpOulmDonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vIOyerOujjCDqsoDsg4kg6rKw6rO8IOygleugrCDtlajsiJhcbmV4cG9ydCBmdW5jdGlvbiBzb3J0SW5ncmVkaWVudHMoaW5ncmVkaWVudHM6IEluZ3JlZGllbnRNYXN0ZXJbXSwgc29ydEJ5OiAnbmFtZScgfCAnZmF2b3JpdGUnIHwgJ3JlY2VudCcgPSAnZmF2b3JpdGUnKTogSW5ncmVkaWVudE1hc3RlcltdIHtcbiAgY29uc3Qgc29ydGVkID0gWy4uLmluZ3JlZGllbnRzXTtcbiAgXG4gIHN3aXRjaCAoc29ydEJ5KSB7XG4gICAgY2FzZSAnbmFtZSc6XG4gICAgICByZXR1cm4gc29ydGVkLnNvcnQoKGEsIGIpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSkpO1xuICAgIGNhc2UgJ2Zhdm9yaXRlJzpcbiAgICAgIHJldHVybiBzb3J0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5pc19mYXZvcml0ZSAmJiAhYi5pc19mYXZvcml0ZSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoIWEuaXNfZmF2b3JpdGUgJiYgYi5pc19mYXZvcml0ZSkgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgfSk7XG4gICAgY2FzZSAncmVjZW50JzpcbiAgICAgIHJldHVybiBzb3J0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkYXRlQSA9IG5ldyBEYXRlKGEuY3JlYXRlZF9hdCB8fCAwKTtcbiAgICAgICAgY29uc3QgZGF0ZUIgPSBuZXcgRGF0ZShiLmNyZWF0ZWRfYXQgfHwgMCk7XG4gICAgICAgIHJldHVybiBkYXRlQi5nZXRUaW1lKCkgLSBkYXRlQS5nZXRUaW1lKCk7XG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgfVxufSBcblxuLy8g65GQIOyerOujjOulvCDthrXtlakobWVyZ2Up7ZWY64qUIO2VqOyImDogb2xkSWTsnZgg66qo65OgIOugiOyLnO2UvOulvCBuZXdJZOuhnCDqtZDssrQsIG9sZElk6rCAIOuNlCDsnbTsg4Eg7IKs7Jqp65CY7KeAIOyViuycvOuptCDsgq3soJxcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtZXJnZUluZ3JlZGllbnRzKG9sZElkOiBzdHJpbmcsIG5ld0lkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICAvLyAxLiDrqqjrk6Ag66CI7Iuc7ZS87JeQ7IScIG9sZElk66W8IG5ld0lk66GcIOq1kOyytFxuICAgIGNvbnN0IHsgZGF0YTogcmVjaXBlcywgZXJyb3I6IHJlY2lwZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3JlY2lwZXMnKVxuICAgICAgLnNlbGVjdCgnaWQsIGluZ3JlZGllbnRzJylcbiAgICAgIC5jb250YWlucygnaW5ncmVkaWVudHMnLCBbeyBpbmdyZWRpZW50X2lkOiBvbGRJZCB9XSk7XG4gICAgaWYgKHJlY2lwZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfroIjsi5ztlLwg7KGw7ZqMIOyLpO2MqDonLCByZWNpcGVFcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVjaXBlIG9mIHJlY2lwZXMgfHwgW10pIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRJbmdyZWRpZW50cyA9IChyZWNpcGUuaW5ncmVkaWVudHMgfHwgW10pLm1hcCgoaW5nOiBhbnkpID0+XG4gICAgICAgIGluZy5pbmdyZWRpZW50X2lkID09PSBvbGRJZCA/IHsgLi4uaW5nLCBpbmdyZWRpZW50X2lkOiBuZXdJZCB9IDogaW5nXG4gICAgICApO1xuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3JlY2lwZXMnKVxuICAgICAgICAudXBkYXRlKHsgaW5ncmVkaWVudHM6IHVwZGF0ZWRJbmdyZWRpZW50cyB9KVxuICAgICAgICAuZXEoJ2lkJywgcmVjaXBlLmlkKTtcbiAgICB9XG4gICAgLy8gMi4gb2xkSWTqsIAg642UIOydtOyDgSDsgqzsmqnrkJjsp4Ag7JWK7Jy866m0IGluZ3JlZGllbnRzX21hc3RlcuyXkOyEnCDsgq3soJxcbiAgICBjb25zdCB7IGRhdGE6IHN0aWxsVXNlZCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdyZWNpcGVzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5jb250YWlucygnaW5ncmVkaWVudHMnLCBbeyBpbmdyZWRpZW50X2lkOiBvbGRJZCB9XSk7XG4gICAgaWYgKCFzdGlsbFVzZWQgfHwgc3RpbGxVc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnaW5ncmVkaWVudHNfbWFzdGVyJykuZGVsZXRlKCkuZXEoJ2lkJywgb2xkSWQpO1xuICAgIH1cbiAgICB0cmlnZ2VySW5ncmVkaWVudFN5bmMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfsnqzro4wg7Ya17ZWpKG1lcmdlKSDspJEg7Jik66WYOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJ2ZXJzaW9uIiwibGlzdGVuZXJzIiwidXNlSW5ncmVkaWVudFN5bmMiLCJzZXRUaWNrIiwib25TeW5jIiwidCIsInB1c2giLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwidHJpZ2dlckluZ3JlZGllbnRTeW5jIiwiZm9yRWFjaCIsImZuIiwic2VhcmNoSW5ncmVkaWVudHMiLCJxdWVyeSIsImxpbWl0IiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImlsaWtlIiwib3JkZXIiLCJhc2NlbmRpbmciLCJjb25zb2xlIiwiZ2V0SW5ncmVkaWVudEJ5SWQiLCJpZCIsImVxIiwic2luZ2xlIiwidXBkYXRlSW5ncmVkaWVudCIsInVwZGF0ZXMiLCJ1cGRhdGUiLCJkZWxldGVJbmdyZWRpZW50SWZVbnVzZWQiLCJyZWNpcGVzIiwicmVjaXBlc0Vycm9yIiwiY29udGFpbnMiLCJpbmdyZWRpZW50X2lkIiwibGVuZ3RoIiwiZGVsZXRlIiwidG9nZ2xlSW5ncmVkaWVudEZhdm9yaXRlIiwiY3VycmVudCIsIm5ld0Zhdm9yaXRlU3RhdGUiLCJpc19mYXZvcml0ZSIsImZpbmRJbmdyZWRpZW50QnlOYW1lIiwibmFtZSIsInRyaW0iLCJjb2RlIiwiY3JlYXRlSW5ncmVkaWVudCIsImluZ3JlZGllbnQiLCJpbnNlcnQiLCJ1bml0Iiwic2hvcF91cmwiLCJnZXRQb3B1bGFySW5ncmVkaWVudHMiLCJmYXZvcml0ZUluZ3JlZGllbnRzIiwiZmF2b3JpdGVFcnJvciIsIk1hdGgiLCJjZWlsIiwicmVtYWluaW5nTGltaXQiLCJyZWNlbnRJbmdyZWRpZW50cyIsInJlY2VudCIsInJlY2VudEVycm9yIiwiYWxsSW5ncmVkaWVudHMiLCJ1bmlxdWVJbmdyZWRpZW50cyIsInJlZHVjZSIsImFjYyIsImV4aXN0cyIsImZpbmQiLCJpdGVtIiwic2xpY2UiLCJzb3J0SW5ncmVkaWVudHMiLCJpbmdyZWRpZW50cyIsInNvcnRCeSIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJkYXRlQSIsIkRhdGUiLCJjcmVhdGVkX2F0IiwiZGF0ZUIiLCJnZXRUaW1lIiwibWVyZ2VJbmdyZWRpZW50cyIsIm9sZElkIiwibmV3SWQiLCJyZWNpcGVFcnJvciIsInJlY2lwZSIsInVwZGF0ZWRJbmdyZWRpZW50cyIsIm1hcCIsImluZyIsInN0aWxsVXNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ingredientSync.ts\n"));

/***/ })

});